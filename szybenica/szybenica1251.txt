Version: 20230216By the same author: Virtour.fr - visites virtuelles
Універсальний автоматичний декодер Кирилиці
Հայերեն - Башҡорт - Беларуская - Български - Иронау - Қазақша - Кыргызча - Македонски - Монгол
Нохчийн - O’zbek - Русский - Slovensky - Српски - Татарча - Тоҷикӣ - Українська - Чaваш - Français - English
You are on a "mirror" site. For the original, probably more up-to-date program, please visit 2cyr.com/decode.
Username (optional)
 
Password
Вставте сюди текст для розкодування (max : 100 kB) :
// szybenica.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include "windows.h"
#include <vector>
using namespace std;

void Color(int color) // ìàëþíêè áóäóòü êîëüîðîâèìè
{
	HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
	SetConsoleTextAttribute(hConsole, color);
}

void Message(int color, string text)
{
	Color(color);
	cout << text;
	Color(7);
}

class Vocabulary // ñëîâíèê
{
private:
	vector<string> words;
	int size;
	int maxwordlength;

public:
	Vocabulary()
	{
		/*ñïèñîê ñë³â*/
		words = { "àáàòñòâî", "àáåòêà", "àá³òóð³ºíò", "àáðèêîñ", "àáñîëþòèçì", "àáñîðáåíò", "àáñòðàêö³îí³çì", "àáñóðä", "àâàíãàðä", "àâ³àêîìïàí³ÿ", "àâ³àêîìïàñ", "àâ³àë³í³ÿ", "àâñòðàë³ÿ", "àâòîáóñ", "àâòîãðàô", "àâòîìîá³ëü", "àâòîðèòåò", "àãàò", "àãåíò", "àãåíòñòâî", "àãðåãàò", "àãðåñ³ÿ", "àãðåñîð", "àãðîíîì", "àãðîíîì³ÿ", "àä þòàíò", "àäâîêàò", "àäåíî¿ä", "àäì³í³ñòðàö³ÿ", "àäì³ðàë", "àäðåñà", "àåðîäðîì", "àåðîçîëü", "àåðîïîðò", "àæ³îòàæ", "àçàðò", "àçèìóò", "àéñáåðã", "àêàäåì³ê", "àêàäåì³ÿ", "àêàäåìêîíöåðò", "àêàô³ñò", "àêâàëàíã", "àêâàðåëü", "àêâàð³óì", "àêîìïàíåìåíò", "àêîðä", "àêîðäåîí", "àêòèâ³ñò", "àêòîð", "àêóëà", "àêóìóëÿòîð", "àêóðàòíî", "àêóñòèêà", "àêóøåð", "àêóøåðêà", "àêö³îíåð", "àêö³ÿ", "àë³ãàòîð", "àëôàâ³ò", "àëüáîì", "àëüïåíøòîê", "àëüï³í³çì", "àëüï³í³ñò", "àëüò", "àëüòåðíàòèâà", "àìá³ö³ÿ", "àìíåç³ÿ", "àìïë³òóäà", "àìïëóà", "àìóí³ö³ÿ", "àìô³á³ÿ", "àìô³òåàòð", "àìôîðà", "àíàë³ç", "àíàë³òèê", "àíàëîã", "àíàìíåç", "àíàíàñ", "àíàðõ³ñò", "àíàòîì³ÿ", "àíàôîðà", "àíãàæåìåíò", "àíãåë", "àíäðî¿ä", "àíåêäîò", "àíåì³ÿ", "àíåñòåç³îëîã", "àíåñòåç³ÿ", "àí³ìàòîð", "àí³ìå", "àíêåòà", "àíêëàâ", "àííîòàö³ÿ", "àíîä", "àíîíñ", "àíñàìáëü", "àíòàãîí³çì", "àíòàðêòèêà", "àíòåíà", "àíòèá³îòèê", "àíòèâ³ðóñ", "àíòèãåí", "àíòèêâàð", "àíòèñåì³òèçì", "àíòèñåïòèê", "àíòèöèêëîí", "àíòè÷í³ñòü", "àíòðàêò", "àíòóðàæ", "àïàðàò", "àïàðàòóðà", "àïàðàòóðèñò", "àïàðàò÷èê", "àïàò³ÿ", "àïåëüñèí", "àïåðèòèâ", "àïåòèò", "àïëîäèñìåíòè", "àïîêàë³ïñèñ", "àïîëîãåò", "àïîëîã³ÿ", "àïîñòîë", "àïîñòðîô", "àïòåêà", "àðá³òð", "àðá³òðàæ", "àðãóìåíò", "àðåàë", "àðåíà", "àðåøò", "àðèñòîêðàò", "àð³ÿ", "àðêà", "àðêóø", "àðìàòóðà", "àðì³ÿ", "àðîìàò", "àðîìàòèçàòîð", "àðñåíàë", "àðòåð³îãðàô³ÿ", "àðòåð³ÿ", "àðòèêóë", "àðòèêóëÿö³ÿ", "àðòèñò", "àðòèñòêà", "àðõåîëîã", "àðõåîëîã³ÿ", "àðõ³â", "àðõ³âàð³óñ", "àðõ³ïåëàã", "àðõ³òåêòîð", "àðõ³òåêòóðà", "àñèìåòð³ÿ", "àñîö³àö³ÿ", "àñïåêò", "àñï³ðàíò", "àñòðîëîã", "àñòðîíàâò", "àñòðîíîì", "àñòðîíîì³ÿ", "àñôàëüò", "àòåëüº", "àòëàñ", "àòîì", "àóäèò", "àóäèòîð", "àóäèòîð³ÿ", "àóòñàéäåð", "àôåðà", "àô³øà", "áàã", "áàãàæ", "áàãàòñòâî", "áàãíåò", "áàæàííÿ", "áàë", "áàëàíñ", "áàëàñò", "áàëåðèíà", "áàëåò", "áàë³ñòèêà", "áàëêà", "áàëêîí", "áàìáóê", "áàíàí", "áàíäóðà", "áàíê", "áàíêåò", "áàíê³ð", "áàíêíîòà", "áàíÿ", "áàð", "áàðàáàí", "áàðàáàíùèê", "áàðàêóäà", "áàðâ³íîê", "áàðåëüºô", "áàðèêàäà", "áàðèñòà", "áàð³ê", "áàðê", "áàðêà", "áàðìàëåé", "áàðìåí", "áàðîêàìåðà", "áàðîêî", "áàðîí", "áàððèêàäà", "áàñ", "áàñåéí", "áàñêåòáîë", "áàñêåòáîë³ñò", "áàñîâà", "áàòàëüéîí", "áàòèñêàô", "áàò³ã", "áàòîã", "áàòîãà", "áàòóò", "áàòüê³âùèíà", "áàøìàê", "áàøòà", "áàÿí", "áåäðî", "áåçìîçîê", "áåçïåêà", "áåçðîá³òòÿ", "áåëåòðèñòèêà", "áåðåã", "áåðåçà", "áåðåò", "áåòîí", "áåòîíîçì³øóâà÷", "áåòîíùèê", "áèëèíà", "áèëî", "á³àòëîí", "á³àòëîí³ñò", "âàãà", "âàãîí", "âàãîíåòêà", "âàãðàíêà", "âàæ³ëü", "âàæëèâ³ñòü", "âàçîí", "âàêàíñ³ÿ", "âàêöèíà", "âàë", "âàëåð³àíà", "âàë³çà", "âàëüñ", "âàëþòà", "âàíäàë", "âàííà", "âàíòàæ", "âàíòàæ³âêà", "âàðåíèê", "âàð³àíò", "âàòà", "âàòàæîê", "âàòìàí", "âàôëÿ", "âàõòåð", "âáðàííÿ", "âãîðó", "âäîâà", "âåãåòàð³àíåöü", "âåäì³äü", "âåæà", "âåëèêäåíü", "âåëè÷", "âåëè÷èíà", "âåëüìîæà", "âåðáà", "âåðáëþä", "âåðåñåíü", "âåðåòåíî", "âåðñòàò", "âåðøèíà", "âåñåëêà", "âåñ³ëëÿ", "âåñëî", "âåñíÿíêà", "âåòåðàí", "âåòåðèíàð", "âå÷³ð", "âå÷³ðêà", "âèá³ð", "âèá³ðêà", "âèáóõ", "â³âòîðîê", "â³âöÿ", "ãàç", "ãàçåòà", "ãàçîïðîâ³ä", "ãàé", "ãàëàêòèêà", "ãàëåðåÿ", "ãàìàíåöü", "ãàíîê", "ãàí÷³ðêà", "ãàíüáà", "ãàðàæ", "ãàðàíò³ÿ", "ãàðáóç", "ãàðäåðîá", "ãàðìîí³ÿ", "ãàðÿ÷à", "ãàñëî", "ãàñòðîëü", "ãåðá", "ãåðî¿í", "ãåðöîã", "ãåòüìàí", "ã³ãàíò", "ã³äðîåëåêòðîñòàíö³ÿ", "ã³ïåðìàðêåò", "ã³òàðà", "ãëàãîë", "ãëàñ", "ãëîáóñ", "ãíîì", "ãîäèíà", "ãîë", "ãîë³âêà", "ãîëîâà", "ãîëóá", "ãîëóáêà", "ãîëóáö³", "ãîëüô", "ãîðà", "ãîðá", "ãîðåöü", "ãîðèçîíò", "ãîð³ëêà", "ãîðëèöÿ", "ãîðëî", "ãîðîáåöü", "ãîðøîê", "ãîñï³òàëü", "ãîòåëü", "ãðàá³æíèê", "ãðàä", "ãðàíàò", "ãðàí³ò", "ãðàô³êà", "ãðåöü", "ãðèâíÿ", "ãðèëü", "ãóáà", "ãóâåðíàíòêà", "ãóäçèê", "ãóìîð", "ãóðà", "ãóñàê", "ãóñêà", "äàëåêîì³ð", "äàìà", "äàò÷èê", "äàõ", "äàõìàò", "äà÷à", "äà÷íèê", "äåáåò", "äåâàëüâàö³ÿ", "äåâ³ç", "äåô³öèò", "äåöåíòðàë³çàö³ÿ", "äæàç", "äæåðåëî", "äæîêåð", "äçâ³í", "äçâ³íîê", "äçèãà", "äèâàí", "äèâåðñàíò", "äèâåðñ³ÿ", "äèâåðòèñìåíò", "äèâ³äåíä", "äèëåìà", "äèïëîì", "äèïëîìàò", "äèïëîìàò³ÿ", "äèðåêòîð", "äèñåðòàö³ÿ", "äèñê", "äèñêîíò", "äèñêîòåêà", "ä³àãíîç", "äîáðå", "äîâãîòà", "äîâ³äêà", "äîâ³ðà", "äîãîâ³ð", "äîçà", "äîçâ³ë", "äîëîíÿ", "äîïîìîãà", "äîñâ³ä", "äî÷êà", "äîøêà", "åêðàí", "åêñêóðñ³ÿ", "åêñïåðèìåíò", "åêñïåðò", "åêñïåðòèçà", "åêñïë³êàö³ÿ", "åêñïëóàòàö³ÿ", "åêñïîçèòóðà", "åêñïîçèö³ÿ", "åêñïðåñ", "åêñïðåñ³îí³çì", "åêñïðåñ³ÿ", "åêñïðîïð³àö³ÿ", "åêñòðàêò", "åêñòðåìàë", "åêñöåíòðèê", "åêñöåñ", "åëàñòè÷í³ñòü", "åëåêòîðàò", "åëåêòðèê", "åëåêòðèêà", "åëåêòðè÷êà", "åëåêòðîä", "åëåêòðîäèíàì³êà", "åëåêòðîìàãí³ò", "åëåêòðîìîòîð", "åëåêòðîí", "åëåêòðîí³êà", "åëåêòðîñòàíö³ÿ", "åëåêòðîòåõí³êà", "åëåìåíò", "åë³òà", "åë³òàðèçì", "åìàëü", "åìáàðãî", "åìáëåìà", "åì³ãðàíò", "åì³ãðàö³ÿ", "åì³ñ³ÿ", "åìîö³éí³ñòü", "åíäåì³ê", "åíåðã³ÿ", "åíòóç³àçì", "åíöèêëîïåä³ÿ", "åïîõà", "åñêàäðà", "ºäí³ñòü", "ºìí³ñòü", "æàáà", "æàãà", "æàíð", "æàðò", "æàñìèí", "æåáðàê", "æåëàòèí", "æåì÷óã", "æåðäèíà", "æåðåáåöü", "æåðëî", "æåðòâà", "æèâ³ò", "æèâîïèñ", "æèâîïèñåöü", "æèòî", "æèòòÿ", "æ³íêà", "æîâòóõà", "æîâ÷", "æîëóäü", "æîíãëåð", "æîðæèíà", "æóïàí", "æóðáà", "æóðíàë", "æóðíàë³ñò", "çàâåðøåííÿ", "çàâ³ñà", "çàâîä", "çàãàðáíèê", "çàãàðáíèöÿ", "çàãèí", "çàãîðîäæåííÿ", "çàãîòîâêà", "çàãðèâîê", "çàãðîçà", "çàäà÷à", "çàäîâîëåííÿ", "çàäóì", "çàçäð³ñòü", "çàç³ðêà", "çàç³õàííÿ", "çàçóáðèíà", "çàêîí", "çàêðèòòÿ", "çàêóñêà", "çàë", "çàëåæí³ñòü", "çàëèâ", "çàë³çî", "çàë³çîáåòîí", "çàë³çîøâåéêà", "çàë³êà", "çàë³ò", "çàìàõ", "çàìåðçàííÿ", "çàì³ææÿ", "çàì³ñ", "çàì³ñíèê", "çàìêíåííÿ", "çàìîæí³ñòü", "çàìîê", "çàìîðîæåííÿ", "çàðÿä", "çåí³ò", "ç³ð", "çîëü - ãåëü", "çîøèò", "³äåíòèô³êàö³ÿ", "³äåÿ", "³íâåñòèö³ÿ", "³íãðåä³ºíò", "³íäåêñ", "³íñòèòóò", "³íñòðóêö³ÿ", "³íñòðóìåíò", "³íñóëüò", "³íòåãðàö³ÿ", "³íòåëåêò", "³íòåë³ãåíö³ÿ", "³íòåíñèâí³ñòü", "³íòåðâàë", "³íòåðåñ", "³íòåðôåéñ", "³íôåêö³ÿ", "³íôëÿö³ÿ", "³íôîðìàö³ÿ", "³íôðàñòðóêòóðà", "³ñïèò", "³ñòîð³ÿ", "³ñòîòà", "¿äàëüíÿ", "¿æà", "¿æàê", "êàâà", "êàâàëåð³ÿ", "êàâóí", "êàäåíö³ÿ", "êàäåò", "êàäèëî", "êàäð", "êàçàí", "êàçàðìà", "êàçêà", "êàçêàð", "êàçóñ", "ê³áåðíåòèêà", "ê³ëîáàéò", "ê³ëîá³ò", "ê³ëîâàò", "ê³ëîãåðö", "ê³ëîãðàì", "ê³ëîìåòð", "ê³íåñòåç³ÿ", "êëÿóçà", "êîáàëüò", "êîâáàñà", "êîâáàñàð", "êîâäðà", "êîâåðò", "êîâçàíêà", "êðàæà", "êðàñóíÿ", "êðåéäà", "êðåéñåð", "êðåì", "êðåìàòîð³é", "êðåìåíü", "êðåñëåííÿ", "êðåñëî", "êðèãà", "êðèæàíêà", "êðèçà", "êðèê", "êðèì³íàë", "êðèì³íàë³ñò", "êðèì³íàë³ñòèêà", "êðèïòà", "êðèïòîãðàìà", "êðèïòîãðàô", "êðèïòîãðàô³ÿ", "êðèñòàë", "êðèñòàë³çàö³ÿ", "êðèñòàëîãðàô", "êðèñòàëîãðàô³ÿ", "êð³ñòàë³çì", "êð³ñòàëîãðàô³ÿ", "êðîâ", "êðîêîäèë", "ëàâà", "ëàä", "ëàê", "ëàêòîçà", "ëàìàíòèí", "ëàì³í³ò", "ëàìïà", "ëàíöþã", "ëàïà", "ëàòóíü", "ëàòôàê", "ëàóðåàò", "ëàóðåàòêà", "ëàóðåàòñòâî", "ëåãåíäà", "ëåäîðóá", "ëåêö³ÿ", "ëåëåêà", "ëèñ", "ë³ñ", "ëîæêà", "ëîêîìîòèâ", "ëþáîâ", "ëþäèíà", "ìàëþíîê", "ìàìà", "ìàìîíò", "ìàíäàðèí", "ìàíäàò", "ìàíäîë³íà", "ìàíäð³âêà", "ìàíäð³âíèê", "ìàíåæ", "ìàíåêåí", "ìàíæåòà", "ìàí³êþð", "ìàí³ïóëÿö³ÿ", "ìàí³ò³", "ìàí³ôåñò", "ìàí³ôåñòàö³ÿ", "ìàíîð", "ìàíñàðäà", "ìàíóåëü", "ìàíóôàêòóðà", "ìàðàôîí", "ìàðãàíåöü", "ìàðæà", "ìàð³îíåòêà", "ìàðêåð", "ìàðêåòèíã", "ìàðê³ç", "ìàðê³ðîâêà", "ìàðêóâàííÿ", "ìàðìóð", "ìàðñ", "ìàðò", "ìàðöèïàí", "ìàðø", "ìàðøðóò", "ìàðøðóòêà", "ìàñàæ", "ìàñàæèñò", "ìàñèâ", "ìàñêà", "ìàñîí", "ìàñøòàá", "ìàòåð³àë", "ìàòåð³àë³çì", "ìàòåð³ÿ", "ìàòè", "ìàô³ÿ", "ìàÿê", "ìàÿòíèê", "ìåä", "ìåäàë³ñò", "ìåäàëü", "ìåä³àòîð", "ìåäîâèê", "ìåäîâóõà", "ìåäóçà", "ìåæà", "ìåçîí³í", "ìåëàíæ", "ìåëàíõîë³ÿ", "ìåë³îðàö³ÿ", "ìåë³ñà", "ìåëîä³ÿ", "ìåëîäðàìà", "ìåëîìàí", "ìåëüíèê", "ìåìóàð", "ìåíåäæåð", "ìåíåäæìåíò", "ìåíåñòðåëü", "ìåíòàë³òåò", "ìåíø³ñòü", "ìåíþ", "ìåð", "ìåðåæà", "ìåðåæèâî", "ìåðèä³àí", "ìåñà", "ìåòàë", "ìåòàëóðã", "ìåòàëóðã³ÿ", "ìåòàìîðôîçà", "ìåòàí", "ìåòàñòàç", "ìåòàñòàçà", "ìåòàô³çèêà", "ìåòàôîðà", "ìåòåîð", "ìåòåîðèò", "ìåòåîðîëîã", "ìåòåîðîëîã³ÿ", "ìåòèñ", "ìåòîä", "ìåòîäèêà", "ìåòîäîëîã³ÿ", "ìåòð", "ìåòðèêà", "ìåòðî", "ìåòðîíîì", "ìåòðîïîë³òåí", "ìåòðîïîë³ÿ", "ìåòóøíÿ", "ìåöåíàò", "ìå÷", "ìå÷åòü", "ìå÷íèê", "íîíà", "îàçèñ", "îáñÿã", "îçîí", "îêàì'ÿí³ë³ñòü", "îêåàíàð³é", "îêîçàìèëþâà÷", "îêðóæí³ñòü", "îêòàâà", "îë³âåöü", "îë³ãàðõ", "îë³ìï³àäà", "îìëåò", "îìí³áóñ", "îìîôîð", "îðàêóë", "îðàíãóòàíã", "îðàíæåðåÿ", "îðãàí³çì", "îðãàíîëîã³ÿ", "îðäà", "îðäåð", "îðäèíàòóðà", "îðåë", "îðåíäàð", "îðèã³íàë", "îðêåñòð", "ïàâè÷", "ïàëåöü", "ïàëèöÿ", "ïàëè÷êà", "ïàëêà", "ïàëüòî", "ïàíÿíêà", "ïàðàçèò", "ïàðàëàêñ", "ïàðàìåäèê", "ïàðàñîëüêà", "ïàðê", "ïàðêàí", "ïàðîäèñò", "ïàðîä³ÿ", "ïàðîëü", "ïàðîí³ì", "ïàðòíåð", "ïàðóáîê", "ïàñàæ", "ïàñàæèðîïîò³ê", "ï'ºñà", "ïèòàííÿ", "ï³âåíü", "ï³âîñòð³â", "ï³äìåò", "ï³äïðèºìñòâî", "ï³äðîçä³ë", "ï³äñòóï", "ï³ñîê", "ï³ñî÷íèöÿ", "ï³ñòîëåò", "ïëèòà", "ïë³âêà", "ïîáðåõåíüêà", "ïîâåðõíÿ", "ïîâ³íü", "ïîâ³ñòü", "ïîâ'ÿçêà", "ïîêîë³ííÿ", "ïîêðèâ", "ïîëå", "ïîëåì³êà", "ïîë³ôîí³ÿ", "ïîëóì'ÿ", "ïîëóíèöÿ", "ïîðÿäîê", "ïîñèëàííÿ", "ïîò³ê", "ïîòðåáà", "ïîòÿã", "ïîõ³äíà", "ïîøòà", "ïðàâî", "ïðàâîçíàâñòâî", "ïðàãìàòèêà", "ïðàïîð", "ïðàïîðåöü", "ïðàñêà", "ïðàõ", "ïðàöÿ", "ïðàùà", "ïðåäñòàâíèê", "ïðåäñòàâíèöÿ", "ïðåçèä³ÿ", "ïðåéñêóðàíò", "ïðåòåíç³ÿ", "ïðåô³êñ", "ïðèáîð", "ïðèáóòîê", "ïðèçìà", "ïðèçíà÷åííÿ", "ïðèçüáà", "ïðèéäåøí³ñòü", "ïðèéìà÷êà", "ïðèéìåííèê", "ïðèêìåòà", "ïðèêìåòíèê", "ïðèëàä", "ïðèìàíêà", "ïðèìàðà", "ïðèì³òèâ", "ïðèì³òêà", "ïðèìîâêà", "ïðèìóñ", "ïðèìõà", "ïðèñêîðåííÿ", "ïðèñêîðþâà÷", "ïðîºêò", "ïðîãðàìóâàííÿ", "ïðîãðàìà", "ïðîãðà³ñò", "ïðîêëÿòòÿ", "ïðîëîã", "ïðîì³ííÿ", "ïðîïàãàíäà", "ïðîïîçèö³ÿ", "ïðîñò³ð", "ïðîòîêîë", "ïðîöåäóðà", "ïóáë³êàö³ÿ", "ïóãà÷", "ïóñòåëÿ", "ïóñòèð", "ðàä³îìåðåæà", "ðàä³îïðèéìà÷", "ðåäàêòîð", "ðåäèñêà", "ðåéäåð", "ðåêàï³òàë³çàö³ÿ", "ðåêëàìà", "ðåë³ã³ÿ", "ðåïîðòàæ", "ðåïðîäóêö³ÿ", "ðåñïóáë³êà", "ðåôëåêñ", "ðå÷åííÿ", "ðå÷îâèíà", "ðåø³òêà", "ðèíîê", "ðèñ³âíèöòâî", "ð³â", "ð³ã", "ð³äèíà", "ð³çíèöÿ", "ð³çíîâèä", "ð³çüáà", "ð³ê", "ð³÷êà", "ð³÷íèöÿ", "ðîáîò", "ðîáîòà", "ðîçà", "ðîçâ'ÿçêà", "ðîçðàõóíîê", "ðîçðîáêà", "ðîìàøêà", "ðîñëèíà", "ðîòîð", "ðóøíèê", "ñàãàéäàê", "ñàéò", "ñàëî", "ñàëîí", "ñâàðêà", "ñâåðäëîâèíà", "ñâ³ò", "ñâ³òàíîê", "ñâ³òëèíà", "ñâ³òëî", "ñåêòà", "ñåêö³ÿ", "ñåëèùå", "ñåëî", "ñåðåäèíà", "ñåðïàíîê", "ñåðöå", "ñèìôîí³ÿ", "ñèñòåìà", "ñ³ëü", "ñ³ëüãîñïïðîäóêö³ÿ", "ñ³ëüãîñïòåõí³êà", "ñêëÿíêà", "ñêîâîðîäà", "ñêðèïêà", "ñëîâíèê", "ñëîâî", "ñëîâîñïîëó÷åííÿ", "ñëîí", "ñëóæáà", "ñìàêîëèê", "ñìàðòôîí", "ñìåðåêà", "ñì³òíèê", "ñìóãà", "ñí³ã", "ñîáîð", "ñîêèðà", "ñîíöå", "ñîï³ëêà", "ñïàäùèíà", "ñïèñ", "ñï³â", "ñï³ëüíèê", "ñï³ëüíîòà", "ñï³íåò", "ñïðàâà", "ñð³áëî", "ñòàíö³ÿ", "ñòèëü", "ñòèïåíä³ÿ", "ñò³ë", "ñò³ëåöü", "ñò³íà", "ñòîäîëà", "ñòîëèöÿ", "ñòðóì", "ñòðóìîê", "ñóáîòà", "ñóä", "ñóäîìà", "ñóìà", "ñóíäóê", "ñóïåðìàðêåò", "ñõèëåííÿ", "ñõ³ä", "ñõîäè", "ñÿì³ñåí" };
		/* ðîç³ìð ñëîâíèêîâî¿ áàçè*/
		size = words.size();

		/*íàéäîâøå ñëîâî*/
		maxwordlength = 0;
		for (int i = 0; i < words.size(); i++)
			if (words[i].length() > maxwordlength) maxwordlength = words[i].length();
	}

	string GetWord(int num)
	{
		if (num >= 0 && num < words.size())
		{
			return words[num];
		}
		else
		{
			return "Ñëîâî íå çíàéäåíî";
		}
	}
	int GetSize()
	{
		return size;
	}
	int GetMaxWordLength()
	{
		return maxwordlength;
	}
};

class WordLength // Íàëàøòóâàííÿ äîâæèíè ñëîâà
{
protected:
	int length;

public:
	WordLength(int max)
	{
		int temp;
		cout << "Ââåä³òü ì³í³ìàëüíó äîâæèíó ñëîâà. Ìàêñèìàëüíå çíà÷åííÿ: " << max << endl;
		do
		{
			cin >> temp;
			if (temp > max)  cout << "Çíà÷åííÿ íå ìîæå ïåðåâèùóâàòè ìàêñèìàëüíå çíà÷åííÿ. Ñïðîáóéòå ùå ðàç.\n";
		} while (temp > max);
		length = temp;
	}

	int GetLength()
	{
		return length;
	}
};

class AttemptsNumber // íàëàøòóâàííÿ ê³ëüêîñò³ ñïðîá
{
protected:
	int attempts;

public:
	AttemptsNumber()
	{
		int tempvalue;
		string temp;
		cout << "Âèáåð³òü ðåæèì: 1 - 6 ñïðîá, 2 - 8 ñïðîá" << endl;
		do
		{
			cin >> temp;
			if (temp == "1") tempvalue = 6;
			else if (temp == "2") tempvalue = 8;
			else cout << "Ñïðîáóéòå ùå ðàç. Âèáåð³òü 1 àáî 2\n";
		} while (temp != "1" && temp != "2");
		attempts = tempvalue;
	}
	int GetNumber()
	{
		return attempts;
	}
};

class Mode // Íàëàøòóâàííÿ ãðè
{
private:
	WordLength* wordlength;
	AttemptsNumber* attemptsnumber;

public:
	Mode(WordLength* wordlength, AttemptsNumber* attemptsnumber)
		: wordlength(wordlength), attemptsnumber(attemptsnumber) {}

	int GetLength()
	{
		return wordlength->GetLength();
	}
	int GetNumber()
	{
		return attemptsnumber->GetNumber();
	}
};


class Choice // ãåíåðàö³ÿ âèïàäêîâèõ ÷èñåë 
{
private:
	int choice;
public:
	Choice(Vocabulary vocabulary) : choice(rand() % vocabulary.GetSize()) {};
	int GetChoice()
	{
		return choice;
	}
};

class Word // ñëîâî ç³ ñëîâíèêà
{
private:
	string word;
	int length;
public:
	Word(string word) : word(word) {
		length = word.length();
	}
	bool Iflength(int length)
	{
		if (this->length >= length) return true;
		else return false;
	}
	Word(Choice num, int wordlength, Vocabulary vocabulary)
	{
		bool iflength = false;
		int choice = num.GetChoice();
		int temp = choice;
		bool trigger = true;
		do
		{
			Word tempword(vocabulary.GetWord(choice));
			if (tempword.Iflength(wordlength)) { word = tempword.GetWord(); break; }
			else
			{
				if (choice < vocabulary.GetSize() - 1 && trigger) choice++;
				else {
					trigger = false;  temp--; choice = temp;
				};
			}
		} while (true);
		length = word.length();
	};
	string GetWord()
	{
		return word;
	}
	int GetLength()
	{
		return length;
	}
	void Show()
	{
		cout << word << endl;
	}
};

class Letter
{
private:
	char letter;
public:
	void SetLetter()
	{
		char temp;
		Message(11, "Ââåä³òü ë³òåðó\n");
		cin >> temp;
		letter = temp;
	}

	char GetLetter()
	{
		return letter;
	}
	void Show()
	{
		cout << letter;
	}

};


class Figure
{
private:
	int attempts;
public:
	Figure(int attempts) : attempts(attempts) {};


	void Draw(int attempt)
	{
		switch (attempt)
		{
		case 8:
			Color(12);
			cout << "-----------------\n"
				<< "|         |      \n"
				<< "|         |      \n"
				<< "|         O      \n"
				<< "|         |      \n"
				<< "|        / \\      \n"
				<< "|       /    \\     \n"
				<< "|                 \n";
			Color(7);
			break;
		case 7:
			Color(14);
			cout << "-----------------\n"
				<< "|         |      \n"
				<< "|         |      \n"
				<< "|         O      \n"
				<< "|         |      \n"
				<< "|        / \\      \n"
				<< "|       /         \n"
				<< "|                 \n";
			Color(7);
			break;
		case 6:
			if (attempts == 6) Color(12);
			cout << "-----------------\n"
				<< "|         |      \n"
				<< "|         O      \n"
				<< "|        -|-     \n"
				<< "|        / \\      \n"
				<< "|                 \n";
			Color(7);
			break;
		case 5:
			if (attempts == 6) Color(14);
			cout << "-----------------\n"
				<< "|         |      \n"
				<< "|         O      \n"
				<< "|        -|-     \n"
				<< "|        /      \n"
				<< "|                 \n";
			Color(7);
			break;
		case 4:
			cout << "-----------------\n"
				<< "|         |      \n"
				<< "|         O      \n"
				<< "|        -|-     \n"
				<< "|                \n"
				<< "|                 \n";
			break;
		case 3:
			cout << "-----------------\n"
				<< "|         |      \n"
				<< "|         O      \n"
				<< "|        -|      \n"
				<< "|                \n"
				<< "|                 \n";
			break;
		case 2:
			cout << "-----------------\n"
				<< "|         |      \n"
				<< "|         O      \n"
				<< "|         |      \n"
				<< "|                \n"
				<< "|                 \n";
			break;
		case 1:
			cout << "-----------------\n"
				<< "|         |      \n"
				<< "|         O      \n"
				<< "|                \n"
				<< "|                \n"
				<< "|                 \n";
			break;
		default:
			cout << "-----------------\n"
				<< "|         |      \n"
				<< "|                \n"
				<< "|                \n"
				<< "|                \n"
				<< "|                 \n";
			break;

		}

	}
};

class WordTable
{
private:
	Word* word;
	Figure* figure;
	Letter letter;
	Mode* mode;
	int length; //äîâæèíà ñëîâà
	bool* ifopen;// ïåðåâ³ðêà ÷è â³äêðèòî ë³òåðó
	int attempts; // íåâäàë³ ñïðîáè
	char* falseletters = nullptr;
	bool victory;// ñèãíàë äî çàâåðøåííÿ ãðè (ïåðåìîãà)
	bool failure;// ñèãíàë äî çàâåðøåííÿ ãðè (ïîðàçêà)


public:
	WordTable(Word* word, Figure* figure, Mode* mode) : word(word), figure(figure), mode(mode)
	{
		length = word->GetLength();
		ifopen = new bool[length];
		for (int i = 0; i < length; i++)
			ifopen[i] = false; // â³ä ïî÷àòêó óñ³ ë³òåðè çàêðèò³
		attempts = 0;
		victory = false;
		failure = false;
	}

	WordTable(const WordTable& obj)
	{
		length = obj.length;
		attempts = obj.attempts;
		ifopen = new bool[length];
		for (int i = 0; i < length; i++)
		{
			ifopen[i] = obj.ifopen[i];
		}
		falseletters = new char[attempts];
		for (int i = 0; i < attempts; i++)
		{
			falseletters[i] = obj.falseletters[i];
		}
		word = obj.word;
		figure = obj.figure;
		letter = obj.letter;
		mode = obj.mode;
		victory = obj.victory;
		failure = obj.failure;
	}

	bool IfFinish() // ÿêùî ñïðîáè âè÷åðïàíî
	{
		if (attempts == mode->GetNumber())
		{
			failure = true;
			return true;
		}
		for (int i = 0; i < length; i++)
		{
			if (ifopen[i] != true) return false;
		}
		victory = true; return true;
	}

	void OpenLetter() // â³äêðèâàºìî ë³òåðè
	{
		bool success = false;
		letter.SetLetter();
		for (int i = 0; i < length; i++)
			if (word->GetWord()[i] == letter.GetLetter())
			{
				ifopen[i] = true; success = true;
			}
		if (!success) AddFalseLetter(letter);
		Show();
		if (!IfFinish()) OpenLetter(); // ÿêùî ñïðîáè âè÷åðïàíî
		else if (victory)
		{
			Message(10, "Âè âãàäàëè!\n");
			Beep(277, 200); Beep(349, 200); Beep(415, 200); Beep(554, 2000);
		}
		else if (failure)
		{
			Message(12, "Íå âãàäàëè!\n");
			Beep(392, 200); Beep(392, 200); Beep(392, 200); Beep(311, 2000);
			word->Show();
		}
	}


	void AddFalseLetter(Letter letter)
	{
		char* temp = new char[attempts + 1];
		for (int i = 0; i < attempts; i++)
		{
			temp[i] = falseletters[i];
		}
		delete[] falseletters;
		temp[attempts] = letter.GetLetter();
		falseletters = temp;
		attempts++;
	}


	void Show()
	{
		system("cls");
		cout << endl;
		Message(11, "Ñëîâî: ");
		Color(15);
		for (int i = 0; i < length; i++)
			if (!ifopen[i]) cout << "_ ";
			else cout << word->GetWord()[i] << " ";
		cout << endl;
		Message(11, "Ïîìèëêè: ");
		Color(12);
		for (int i = 0; i < attempts; i++)
		{
			cout << falseletters[i];
			if (i < attempts - 1) cout << ", ";
			else cout << ".\n";
		}
		Color(7);
		cout << endl;
		figure->Draw(attempts);
	}


	~WordTable()
	{
		delete[] ifopen;
		delete[] falseletters;
	}

};





int main()
{
	setlocale(LC_ALL, "ukr");
	SetConsoleOutputCP(1251);
	SetConsoleCP(1251);
	srand(time(NULL));

	/*Ñëîâíèê*/
	Vocabulary vocabulary;

	/* Âñòàíîâëþìî íàëàøòóâàííÿ */
	WordLength wordlength(vocabulary.GetMaxWordLength());
	AttemptsNumber attemptsnumber;
	Mode gamemode(&wordlength, &attemptsnumber);

	/* Êîìï'þòåð çàãàäóº ñëîâî */
	Choice choice(vocabulary);
	Word word(choice, gamemode.GetLength(), vocabulary);
	Figure figure(gamemode.GetNumber());
	WordTable wordtable(&word, &figure, &gamemode);

	//word.Show(); system("pause"); //Òåñò: âèâîäèìî íà åêðàí ñëîâî, çàãàäàíå êîìï'þòåðîì, ï³ä ÷àñ ãðè öÿ ôóíêö³ÿ ìàº áóòè âèìêíåíà

		/* Ãðà */
	wordtable.Show();
	wordtable.OpenLetter();


}


Виберіть кодування : 
Reuse current settings
АБО	Виберіть текст : 
Виберіть найкращий зразок :
АБО	Експерт: спотворений текст: 
WINDOWS-1251
 показати так: 
WINDOWS-1252
 додатковий фільтр: 
Результат BUL→LAT RUS→LAT(спотворений текст : WINDOWS-1251) 
// szybenica.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include "windows.h"
#include <vector>
using namespace std;

void Color(int color) // малюнки будуть кольоровими
{
	HANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);
	SetConsoleTextAttribute(hConsole, color);
}

void Message(int color, string text)
{
	Color(color);
	cout << text;
	Color(7);
}

class Vocabulary // словник
{
private:
	vector<string> words;
	int size;
	int maxwordlength;

public:
	Vocabulary()
	{
		/*список слів*/
		words = { "абатство", "абетка", "абітурієнт", "абрикос", "абсолютизм", "абсорбент", "абстракціонізм", "абсурд", "авангард", "авіакомпанія", "авіакомпас", "авіалінія", "австралія", "автобус", "автограф", "автомобіль", "авторитет", "агат", "агент", "агентство", "агрегат", "агресія", "агресор", "агроном", "агрономія", "ад ютант", "адвокат", "аденоїд", "адміністрація", "адмірал", "адреса", "аеродром", "аерозоль", "аеропорт", "ажіотаж", "азарт", "азимут", "айсберг", "академік", "академія", "академконцерт", "акафіст", "акваланг", "акварель", "акваріум", "акомпанемент", "акорд", "акордеон", "активіст", "актор", "акула", "акумулятор", "акуратно", "акустика", "акушер", "акушерка", "акціонер", "акція", "алігатор", "алфавіт", "альбом", "альпеншток", "альпінізм", "альпініст", "альт", "альтернатива", "амбіція", "амнезія", "амплітуда", "амплуа", "амуніція", "амфібія", "амфітеатр", "амфора", "аналіз", "аналітик", "аналог", "анамнез", "ананас", "анархіст", "анатомія", "анафора", "ангажемент", "ангел", "андроїд", "анекдот", "анемія", "анестезіолог", "анестезія", "аніматор", "аніме", "анкета", "анклав", "аннотація", "анод", "анонс", "ансамбль", "антагонізм", "антарктика", "антена", "антибіотик", "антивірус", "антиген", "антиквар", "антисемітизм", "антисептик", "антициклон", "античність", "антракт", "антураж", "апарат", "апаратура", "апаратурист", "апаратчик", "апатія", "апельсин", "аперитив", "апетит", "аплодисменти", "апокаліпсис", "апологет", "апологія", "апостол", "апостроф", "аптека", "арбітр", "арбітраж", "аргумент", "ареал", "арена", "арешт", "аристократ", "арія", "арка", "аркуш", "арматура", "армія", "аромат", "ароматизатор", "арсенал", "артеріографія", "артерія", "артикул", "артикуляція", "артист", "артистка", "археолог", "археологія", "архів", "архіваріус", "архіпелаг", "архітектор", "архітектура", "асиметрія", "асоціація", "аспект", "аспірант", "астролог", "астронавт", "астроном", "астрономія", "асфальт", "ательє", "атлас", "атом", "аудит", "аудитор", "аудиторія", "аутсайдер", "афера", "афіша", "баг", "багаж", "багатство", "багнет", "бажання", "бал", "баланс", "баласт", "балерина", "балет", "балістика", "балка", "балкон", "бамбук", "банан", "бандура", "банк", "банкет", "банкір", "банкнота", "баня", "бар", "барабан", "барабанщик", "баракуда", "барвінок", "барельєф", "барикада", "бариста", "барік", "барк", "барка", "бармалей", "бармен", "барокамера", "бароко", "барон", "баррикада", "бас", "басейн", "баскетбол", "баскетболіст", "басова", "батальйон", "батискаф", "батіг", "батог", "батога", "батут", "батьківщина", "башмак", "башта", "баян", "бедро", "безмозок", "безпека", "безробіття", "белетристика", "берег", "береза", "берет", "бетон", "бетонозмішувач", "бетонщик", "билина", "било", "біатлон", "біатлоніст", "вага", "вагон", "вагонетка", "вагранка", "важіль", "важливість", "вазон", "вакансія", "вакцина", "вал", "валеріана", "валіза", "вальс", "валюта", "вандал", "ванна", "вантаж", "вантажівка", "вареник", "варіант", "вата", "ватажок", "ватман", "вафля", "вахтер", "вбрання", "вгору", "вдова", "вегетаріанець", "ведмідь", "вежа", "великдень", "велич", "величина", "вельможа", "верба", "верблюд", "вересень", "веретено", "верстат", "вершина", "веселка", "весілля", "весло", "веснянка", "ветеран", "ветеринар", "вечір", "вечірка", "вибір", "вибірка", "вибух", "вівторок", "вівця", "газ", "газета", "газопровід", "гай", "галактика", "галерея", "гаманець", "ганок", "ганчірка", "ганьба", "гараж", "гарантія", "гарбуз", "гардероб", "гармонія", "гаряча", "гасло", "гастроль", "герб", "героїн", "герцог", "гетьман", "гігант", "гідроелектростанція", "гіпермаркет", "гітара", "глагол", "глас", "глобус", "гном", "година", "гол", "голівка", "голова", "голуб", "голубка", "голубці", "гольф", "гора", "горб", "горець", "горизонт", "горілка", "горлиця", "горло", "горобець", "горшок", "госпіталь", "готель", "грабіжник", "град", "гранат", "граніт", "графіка", "грець", "гривня", "гриль", "губа", "гувернантка", "гудзик", "гумор", "гура", "гусак", "гуска", "далекомір", "дама", "датчик", "дах", "дахмат", "дача", "дачник", "дебет", "девальвація", "девіз", "дефіцит", "децентралізація", "джаз", "джерело", "джокер", "дзвін", "дзвінок", "дзига", "диван", "диверсант", "диверсія", "дивертисмент", "дивіденд", "дилема", "диплом", "дипломат", "дипломатія", "директор", "дисертація", "диск", "дисконт", "дискотека", "діагноз", "добре", "довгота", "довідка", "довіра", "договір", "доза", "дозвіл", "долоня", "допомога", "досвід", "дочка", "дошка", "екран", "екскурсія", "експеримент", "експерт", "експертиза", "експлікація", "експлуатація", "експозитура", "експозиція", "експрес", "експресіонізм", "експресія", "експропріація", "екстракт", "екстремал", "ексцентрик", "ексцес", "еластичність", "електорат", "електрик", "електрика", "електричка", "електрод", "електродинаміка", "електромагніт", "електромотор", "електрон", "електроніка", "електростанція", "електротехніка", "елемент", "еліта", "елітаризм", "емаль", "ембарго", "емблема", "емігрант", "еміграція", "емісія", "емоційність", "ендемік", "енергія", "ентузіазм", "енциклопедія", "епоха", "ескадра", "єдність", "ємність", "жаба", "жага", "жанр", "жарт", "жасмин", "жебрак", "желатин", "жемчуг", "жердина", "жеребець", "жерло", "жертва", "живіт", "живопис", "живописець", "жито", "життя", "жінка", "жовтуха", "жовч", "жолудь", "жонглер", "жоржина", "жупан", "журба", "журнал", "журналіст", "завершення", "завіса", "завод", "загарбник", "загарбниця", "загин", "загородження", "заготовка", "загривок", "загроза", "задача", "задоволення", "задум", "заздрість", "зазірка", "зазіхання", "зазубрина", "закон", "закриття", "закуска", "зал", "залежність", "залив", "залізо", "залізобетон", "залізошвейка", "заліка", "заліт", "замах", "замерзання", "заміжжя", "заміс", "замісник", "замкнення", "заможність", "замок", "замороження", "заряд", "зеніт", "зір", "золь - гель", "зошит", "ідентифікація", "ідея", "інвестиція", "інгредієнт", "індекс", "інститут", "інструкція", "інструмент", "інсульт", "інтеграція", "інтелект", "інтелігенція", "інтенсивність", "інтервал", "інтерес", "інтерфейс", "інфекція", "інфляція", "інформація", "інфраструктура", "іспит", "історія", "істота", "їдальня", "їжа", "їжак", "кава", "кавалерія", "кавун", "каденція", "кадет", "кадило", "кадр", "казан", "казарма", "казка", "казкар", "казус", "кібернетика", "кілобайт", "кілобіт", "кіловат", "кілогерц", "кілограм", "кілометр", "кінестезія", "кляуза", "кобальт", "ковбаса", "ковбасар", "ковдра", "коверт", "ковзанка", "кража", "красуня", "крейда", "крейсер", "крем", "крематорій", "кремень", "креслення", "кресло", "крига", "крижанка", "криза", "крик", "кримінал", "криміналіст", "криміналістика", "крипта", "криптограма", "криптограф", "криптографія", "кристал", "кристалізація", "кристалограф", "кристалографія", "крісталізм", "крісталографія", "кров", "крокодил", "лава", "лад", "лак", "лактоза", "ламантин", "ламініт", "лампа", "ланцюг", "лапа", "латунь", "латфак", "лауреат", "лауреатка", "лауреатство", "легенда", "ледоруб", "лекція", "лелека", "лис", "ліс", "ложка", "локомотив", "любов", "людина", "малюнок", "мама", "мамонт", "мандарин", "мандат", "мандоліна", "мандрівка", "мандрівник", "манеж", "манекен", "манжета", "манікюр", "маніпуляція", "маніті", "маніфест", "маніфестація", "манор", "мансарда", "мануель", "мануфактура", "марафон", "марганець", "маржа", "маріонетка", "маркер", "маркетинг", "маркіз", "маркіровка", "маркування", "мармур", "марс", "март", "марципан", "марш", "маршрут", "маршрутка", "масаж", "масажист", "масив", "маска", "масон", "масштаб", "матеріал", "матеріалізм", "матерія", "мати", "мафія", "маяк", "маятник", "мед", "медаліст", "медаль", "медіатор", "медовик", "медовуха", "медуза", "межа", "мезонін", "меланж", "меланхолія", "меліорація", "меліса", "мелодія", "мелодрама", "меломан", "мельник", "мемуар", "менеджер", "менеджмент", "менестрель", "менталітет", "меншість", "меню", "мер", "мережа", "мереживо", "меридіан", "меса", "метал", "металург", "металургія", "метаморфоза", "метан", "метастаз", "метастаза", "метафізика", "метафора", "метеор", "метеорит", "метеоролог", "метеорологія", "метис", "метод", "методика", "методологія", "метр", "метрика", "метро", "метроном", "метрополітен", "метрополія", "метушня", "меценат", "меч", "мечеть", "мечник", "нона", "оазис", "обсяг", "озон", "окам'янілість", "океанарій", "окозамилювач", "окружність", "октава", "олівець", "олігарх", "олімпіада", "омлет", "омнібус", "омофор", "оракул", "орангутанг", "оранжерея", "організм", "органологія", "орда", "ордер", "ординатура", "орел", "орендар", "оригінал", "оркестр", "павич", "палець", "палиця", "паличка", "палка", "пальто", "панянка", "паразит", "паралакс", "парамедик", "парасолька", "парк", "паркан", "пародист", "пародія", "пароль", "паронім", "партнер", "парубок", "пасаж", "пасажиропотік", "п'єса", "питання", "півень", "півострів", "підмет", "підприємство", "підрозділ", "підступ", "пісок", "пісочниця", "пістолет", "плита", "плівка", "побрехенька", "поверхня", "повінь", "повість", "пов'язка", "покоління", "покрив", "поле", "полеміка", "поліфонія", "полум'я", "полуниця", "порядок", "посилання", "потік", "потреба", "потяг", "похідна", "пошта", "право", "правознавство", "прагматика", "прапор", "прапорець", "праска", "прах", "праця", "праща", "представник", "представниця", "президія", "прейскурант", "претензія", "префікс", "прибор", "прибуток", "призма", "призначення", "призьба", "прийдешність", "приймачка", "прийменник", "прикмета", "прикметник", "прилад", "приманка", "примара", "примітив", "примітка", "примовка", "примус", "примха", "прискорення", "прискорювач", "проєкт", "програмування", "програма", "програіст", "прокляття", "пролог", "проміння", "пропаганда", "пропозиція", "простір", "протокол", "процедура", "публікація", "пугач", "пустеля", "пустир", "радіомережа", "радіоприймач", "редактор", "редиска", "рейдер", "рекапіталізація", "реклама", "релігія", "репортаж", "репродукція", "республіка", "рефлекс", "речення", "речовина", "решітка", "ринок", "рисівництво", "рів", "ріг", "рідина", "різниця", "різновид", "різьба", "рік", "річка", "річниця", "робот", "робота", "роза", "розв'язка", "розрахунок", "розробка", "ромашка", "рослина", "ротор", "рушник", "сагайдак", "сайт", "сало", "салон", "сварка", "свердловина", "світ", "світанок", "світлина", "світло", "секта", "секція", "селище", "село", "середина", "серпанок", "серце", "симфонія", "система", "сіль", "сільгосппродукція", "сільгосптехніка", "склянка", "сковорода", "скрипка", "словник", "слово", "словосполучення", "слон", "служба", "смаколик", "смартфон", "смерека", "смітник", "смуга", "сніг", "собор", "сокира", "сонце", "сопілка", "спадщина", "спис", "спів", "спільник", "спільнота", "спінет", "справа", "срібло", "станція", "стиль", "стипендія", "стіл", "стілець", "стіна", "стодола", "столиця", "струм", "струмок", "субота", "суд", "судома", "сума", "сундук", "супермаркет", "схилення", "схід", "сходи", "сямісен" };
		/* розімр словникової бази*/
		size = words.size();

		/*найдовше слово*/
		maxwordlength = 0;
		for (int i = 0; i < words.size(); i++)
			if (words[i].length() > maxwordlength) maxwordlength = words[i].length();
	}

	string GetWord(int num)
	{
		if (num >= 0 && num < words.size())
		{
			return words[num];
		}
		else
		{
			return "Слово не знайдено";
		}
	}
	int GetSize()
	{
		return size;
	}
	int GetMaxWordLength()
	{
		return maxwordlength;
	}
};

class WordLength // Налаштування довжини слова
{
protected:
	int length;

public:
	WordLength(int max)
	{
		int temp;
		cout << "Введіть мінімальну довжину слова. Максимальне значення: " << max << endl;
		do
		{
			cin >> temp;
			if (temp > max)  cout << "Значення не може перевищувати максимальне значення. Спробуйте ще раз.\n";
		} while (temp > max);
		length = temp;
	}

	int GetLength()
	{
		return length;
	}
};

class AttemptsNumber // налаштування кількості спроб
{
protected:
	int attempts;

public:
	AttemptsNumber()
	{
		int tempvalue;
		string temp;
		cout << "Виберіть режим: 1 - 6 спроб, 2 - 8 спроб" << endl;
		do
		{
			cin >> temp;
			if (temp == "1") tempvalue = 6;
			else if (temp == "2") tempvalue = 8;
			else cout << "Спробуйте ще раз. Виберіть 1 або 2\n";
		} while (temp != "1" && temp != "2");
		attempts = tempvalue;
	}
	int GetNumber()
	{
		return attempts;
	}
};

class Mode // Налаштування гри
{
private:
	WordLength* wordlength;
	AttemptsNumber* attemptsnumber;

public:
	Mode(WordLength* wordlength, AttemptsNumber* attemptsnumber)
		: wordlength(wordlength), attemptsnumber(attemptsnumber) {}

	int GetLength()
	{
		return wordlength->GetLength();
	}
	int GetNumber()
	{
		return attemptsnumber->GetNumber();
	}
};


class Choice // генерація випадкових чисел 
{
private:
	int choice;
public:
	Choice(Vocabulary vocabulary) : choice(rand() % vocabulary.GetSize()) {};
	int GetChoice()
	{
		return choice;
	}
};

class Word // слово зі словника
{
private:
	string word;
	int length;
public:
	Word(string word) : word(word) {
		length = word.length();
	}
	bool Iflength(int length)
	{
		if (this->length >= length) return true;
		else return false;
	}
	Word(Choice num, int wordlength, Vocabulary vocabulary)
	{
		bool iflength = false;
		int choice = num.GetChoice();
		int temp = choice;
		bool trigger = true;
		do
		{
			Word tempword(vocabulary.GetWord(choice));
			if (tempword.Iflength(wordlength)) { word = tempword.GetWord(); break; }
			else
			{
				if (choice < vocabulary.GetSize() - 1 && trigger) choice++;
				else {
					trigger = false;  temp--; choice = temp;
				};
			}
		} while (true);
		length = word.length();
	};
	string GetWord()
	{
		return word;
	}
	int GetLength()
	{
		return length;
	}
	void Show()
	{
		cout << word << endl;
	}
};

class Letter
{
private:
	char letter;
public:
	void SetLetter()
	{
		char temp;
		Message(11, "Введіть літеру\n");
		cin >> temp;
		letter = temp;
	}

	char GetLetter()
	{
		return letter;
	}
	void Show()
	{
		cout << letter;
	}

};


class Figure
{
private:
	int attempts;
public:
	Figure(int attempts) : attempts(attempts) {};


	void Draw(int attempt)
	{
		switch (attempt)
		{
		case 8:
			Color(12);
			cout << "-----------------\n"
				<< "|         |      \n"
				<< "|         |      \n"
				<< "|         O      \n"
				<< "|         |      \n"
				<< "|        / \\      \n"
				<< "|       /    \\     \n"
				<< "|                 \n";
			Color(7);
			break;
		case 7:
			Color(14);
			cout << "-----------------\n"
				<< "|         |      \n"
				<< "|         |      \n"
				<< "|         O      \n"
				<< "|         |      \n"
				<< "|        / \\      \n"
				<< "|       /         \n"
				<< "|                 \n";
			Color(7);
			break;
		case 6:
			if (attempts == 6) Color(12);
			cout << "-----------------\n"
				<< "|         |      \n"
				<< "|         O      \n"
				<< "|        -|-     \n"
				<< "|        / \\      \n"
				<< "|                 \n";
			Color(7);
			break;
		case 5:
			if (attempts == 6) Color(14);
			cout << "-----------------\n"
				<< "|         |      \n"
				<< "|         O      \n"
				<< "|        -|-     \n"
				<< "|        /      \n"
				<< "|                 \n";
			Color(7);
			break;
		case 4:
			cout << "-----------------\n"
				<< "|         |      \n"
				<< "|         O      \n"
				<< "|        -|-     \n"
				<< "|                \n"
				<< "|                 \n";
			break;
		case 3:
			cout << "-----------------\n"
				<< "|         |      \n"
				<< "|         O      \n"
				<< "|        -|      \n"
				<< "|                \n"
				<< "|                 \n";
			break;
		case 2:
			cout << "-----------------\n"
				<< "|         |      \n"
				<< "|         O      \n"
				<< "|         |      \n"
				<< "|                \n"
				<< "|                 \n";
			break;
		case 1:
			cout << "-----------------\n"
				<< "|         |      \n"
				<< "|         O      \n"
				<< "|                \n"
				<< "|                \n"
				<< "|                 \n";
			break;
		default:
			cout << "-----------------\n"
				<< "|         |      \n"
				<< "|                \n"
				<< "|                \n"
				<< "|                \n"
				<< "|                 \n";
			break;

		}

	}
};

class WordTable
{
private:
	Word* word;
	Figure* figure;
	Letter letter;
	Mode* mode;
	int length; //довжина слова
	bool* ifopen;// перевірка чи відкрито літеру
	int attempts; // невдалі спроби
	char* falseletters = nullptr;
	bool victory;// сигнал до завершення гри (перемога)
	bool failure;// сигнал до завершення гри (поразка)


public:
	WordTable(Word* word, Figure* figure, Mode* mode) : word(word), figure(figure), mode(mode)
	{
		length = word->GetLength();
		ifopen = new bool[length];
		for (int i = 0; i < length; i++)
			ifopen[i] = false; // від початку усі літери закриті
		attempts = 0;
		victory = false;
		failure = false;
	}

	WordTable(const WordTable& obj)
	{
		length = obj.length;
		attempts = obj.attempts;
		ifopen = new bool[length];
		for (int i = 0; i < length; i++)
		{
			ifopen[i] = obj.ifopen[i];
		}
		falseletters = new char[attempts];
		for (int i = 0; i < attempts; i++)
		{
			falseletters[i] = obj.falseletters[i];
		}
		word = obj.word;
		figure = obj.figure;
		letter = obj.letter;
		mode = obj.mode;
		victory = obj.victory;
		failure = obj.failure;
	}

	bool IfFinish() // якщо спроби вичерпано
	{
		if (attempts == mode->GetNumber())
		{
			failure = true;
			return true;
		}
		for (int i = 0; i < length; i++)
		{
			if (ifopen[i] != true) return false;
		}
		victory = true; return true;
	}

	void OpenLetter() // відкриваємо літери
	{
		bool success = false;
		letter.SetLetter();
		for (int i = 0; i < length; i++)
			if (word->GetWord()[i] == letter.GetLetter())
			{
				ifopen[i] = true; success = true;
			}
		if (!success) AddFalseLetter(letter);
		Show();
		if (!IfFinish()) OpenLetter(); // якщо спроби вичерпано
		else if (victory)
		{
			Message(10, "Ви вгадали!\n");
			Beep(277, 200); Beep(349, 200); Beep(415, 200); Beep(554, 2000);
		}
		else if (failure)
		{
			Message(12, "Не вгадали!\n");
			Beep(392, 200); Beep(392, 200); Beep(392, 200); Beep(311, 2000);
			word->Show();
		}
	}


	void AddFalseLetter(Letter letter)
	{
		char* temp = new char[attempts + 1];
		for (int i = 0; i < attempts; i++)
		{
			temp[i] = falseletters[i];
		}
		delete[] falseletters;
		temp[attempts] = letter.GetLetter();
		falseletters = temp;
		attempts++;
	}


	void Show()
	{
		system("cls");
		cout << endl;
		Message(11, "Слово: ");
		Color(15);
		for (int i = 0; i < length; i++)
			if (!ifopen[i]) cout << "_ ";
			else cout << word->GetWord()[i] << " ";
		cout << endl;
		Message(11, "Помилки: ");
		Color(12);
		for (int i = 0; i < attempts; i++)
		{
			cout << falseletters[i];
			if (i < attempts - 1) cout << ", ";
			else cout << ".\n";
		}
		Color(7);
		cout << endl;
		figure->Draw(attempts);
	}


	~WordTable()
	{
		delete[] ifopen;
		delete[] falseletters;
	}

};





int main()
{
	setlocale(LC_ALL, "ukr");
	SetConsoleOutputCP(1251);
	SetConsoleCP(1251);
	srand(time(NULL));

	/*Словник*/
	Vocabulary vocabulary;

	/* Встановлюмо налаштування */
	WordLength wordlength(vocabulary.GetMaxWordLength());
	AttemptsNumber attemptsnumber;
	Mode gamemode(&wordlength, &attemptsnumber);

	/* Комп'ютер загадує слово */
	Choice choice(vocabulary);
	Word word(choice, gamemode.GetLength(), vocabulary);
	Figure figure(gamemode.GetNumber());
	WordTable wordtable(&word, &figure, &gamemode);

	//word.Show(); system("pause"); //Тест: виводимо на екран слово, загадане комп'ютером, під час гри ця функція має бути вимкнена

		/* Гра */
	wordtable.Show();
	wordtable.OpenLetter();


}